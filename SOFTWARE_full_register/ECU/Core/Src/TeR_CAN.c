/*
 * TeR_CAN.c
 *
 *      Author: Nguyen Nhan
 *
 * ████████╗███████╗██████╗          ██████╗ █████╗ ███╗   ██╗
 * ╚══██╔══╝██╔════╝██╔══██╗        ██╔════╝██╔══██╗████╗  ██║
 *    ██║   █████╗  ██████╔╝        ██║     ███████║██╔██╗ ██║
 *    ██║   ██╔══╝  ██╔══██╗        ██║     ██╔══██║██║╚██╗██║
 *    ██║   ███████╗██║  ██║███████╗╚██████╗██║  ██║██║ ╚████║
 *    ╚═╝   ╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝
 */

/*
 *  This file aims to store the decoding and sending functions
 *  of all messages from a board, includes as libraries those
 *  autogenerated using cantools and offers an interface to the micro with two
 *  Functions:
 *  - decodeMSG -> Decodes the relevant structures
 *  - sendCAN -> Sends the relevant messages (This will not depend on the state, since the inverters will always be at 0)
 *  - command -> Function called when the command message is received so that each board interprets it as appropriate
 *  All CAN memory structures are created here
 *
 */
#include "TeR_CAN.h"
#include "stm32f4xx.h"  // For CAN and TIM registers

/* ---------------------------[CAN Structures]-------------------------- */
// Pointer to timer and CAN peripheral being used
CAN_TypeDef *invCAN;   // Inverter CAN bus
CAN_TypeDef *mainCAN;  // Main CAN bus

TIM_TypeDef *invTIM;   // Timer for inverter CAN
TIM_TypeDef *mainTIM;  // Timer for main CAN

// Index for CAN senders
uint8_t invIndex;      // Index for inverter messages
uint8_t mainIndex;     // Index for main messages
/* -------------------------------------------------------------------------- */

// Global TeR structure
struct TeR_t TeR;

/* ---------------------------[Initialization + Interrupts]-------------------------- */

// Initialize CAN buses and timers
uint8_t initCAN(CAN_TypeDef *invCan, CAN_TypeDef *mainCan,
		TIM_TypeDef *hInvTIM, TIM_TypeDef *hMainTIM) {
	// Initialize CAN peripherals
	invCAN = invCan;   // Assign inverter CAN
	mainCAN = mainCan; // Assign main CAN
	// Attach timers
	invTIM = hInvTIM;  // Assign inverter timer
	mainTIM = hMainTIM;// Assign main timer

	// Start peripheral and interrupt
	configFilter(invCan, mainCan); // Configure filters

	// No HAL callbacks; use direct IRQHandlers in startup file

	// Start modules
	invCan->MCR &= ~CAN_MCR_SLEEP;  // Wake up inverter CAN
	mainCan->MCR &= ~CAN_MCR_SLEEP; // Wake up main CAN

	// Start timers
	invTIM->CR1 |= TIM_CR1_CEN; // Start inverter timer
	mainTIM->CR1 |= TIM_CR1_CEN;// Start main timer
	return 1;                   // Return success
}
/*----------------------------------[Filter Configuration]--------------------------------*/

// Configure CAN filters
void configFilter(CAN_TypeDef *invCan, CAN_TypeDef *mainCan) {
	// Enter filter init mode for invCan
	invCan->FMR |= CAN_FMR_FINIT;  // Enter filter init mode
	// Activate filter banks (example for full configuration)
	invCan->FA1R |= CAN_FA1R_FACT0 | CAN_FA1R_FACT1;  // Activate filter 0 and 1
	invCan->FS1R |= CAN_FS1R_FSC0 | CAN_FS1R_FSC1;    // 32-bit scale for filters 0 and 1
	invCan->FM1R &= ~(CAN_FM1R_FBM0 | CAN_FM1R_FBM1); // Mask mode for filters 0 and 1
	// Set filter for inverter messages (example IDs, adjust based on needs)
	invCan->sFilterRegister[0].FR1 = (INVERTER_EMCU_STATE_2_RIGHT_FRAME_ID << 5);  // Filter ID for right state 2
	invCan->sFilterRegister[0].FR2 = 0xFFE00000;  // Mask to match ID
	invCan->sFilterRegister[1].FR1 = (INVERTER_EMCU_STATE_2_LEFT_FRAME_ID << 5);   // Filter ID for left state 2
	invCan->sFilterRegister[1].FR2 = 0xFFE00000;  // Mask
	// Assign filters to FIFO0
	invCan->FFA1R &= ~(CAN_FFA1R_FFA0 | CAN_FFA1R_FFA1); // Assign to FIFO0
	// Exit filter init mode
	invCan->FMR &= ~CAN_FMR_FINIT;  // Exit filter init mode

	// Similar for mainCan
	mainCan->FMR |= CAN_FMR_FINIT;  // Enter filter init mode
	mainCan->FA1R |= CAN_FA1R_FACT14 | CAN_FA1R_FACT15;  // Activate higher banks for mainCan (since CAN2 shares filters)
	mainCan->FS1R |= CAN_FS1R_FSC14 | CAN_FS1R_FSC15;    // 32-bit scale
	mainCan->FM1R &= ~(CAN_FM1R_FBM14 | CAN_FM1R_FBM15); // Mask mode
	// Set filter for main messages (example)
	mainCan->sFilterRegister[14].FR1 = (TER_COMMAND_FRAME_ID << 5);  // Filter for command ID
	mainCan->sFilterRegister[14].FR2 = 0xFFE00000;  // Mask
	mainCan->sFilterRegister[15].FR1 = (HVBMS_BMS_TX_STATE_3_FRAME_ID << 5);  // Filter for BMS state
	mainCan->sFilterRegister[15].FR2 = 0xFFE00000;  // Mask
	// Assign to FIFO0
	mainCan->FFA1R &= ~(CAN_FFA1R_FFA14 | CAN_FFA1R_FFA15); // FIFO0
	mainCan->FMR &= ~CAN_FMR_FINIT;  // Exit
}

// Send function for inverter CAN (on timer callback)
void sendInvCAN(TIM_TypeDef *tim) {
	uint8_t TxData[8]; // Data buffer for transmission
	CAN_TxHeaderTypeDef TxHeader; // Transmission header struct
	uint32_t mailbox = 0; // Mailbox index (use 0 for simplicity)
	// Reset index if needed
	if (invIndex >= NUM_INV_MESSAGES) { // Assume NUM_INV_MESSAGES is defined as number of inverter messages
		invIndex = 0; // Reset to first message
	}
	// Prepare message based on index (example logic for sending inverter requests)
	TxHeader.StdId = INVERTER_APP_REQ_RIGHT_FRAME_ID; // Example ID for right inverter app request
	TxHeader.DLC = INVERTER_APP_REQ_RIGHT_LENGTH; // Length
	TxHeader.IDE = CAN_ID_STD; // Standard ID
	TxHeader.RTR = CAN_RTR_DATA; // Data frame
	inverter_app_req_right_pack(TxData, &TeR.appReqRight, TxHeader.DLC); // Pack data for right inverter
	// Bare-metal send
	while ((invCAN->TSR & CAN_TSR_TME0) == 0); // Wait for mailbox 0 empty
	invCAN->sTxMailBox[0].TIR = (TxHeader.StdId << 21) | (TxHeader.IDE << 2) | (TxHeader.RTR << 1); // Set ID, IDE, RTR
	invCAN->sTxMailBox[0].TDTR = TxHeader.DLC; // Set DLC
	invCAN->sTxMailBox[0].TDLR = *(uint32_t*)TxData; // Low data bytes
	invCAN->sTxMailBox[0].TDHR = *(uint32_t*)(TxData + 4); // High data bytes
	invCAN->sTxMailBox[0].TIR |= CAN_TI0R_TXRQ; // Transmit request
	invIndex++; // Increment index for next message
}

// Send function for main CAN (on timer callback)
void sendMainCAN(TIM_TypeDef *tim) {
	uint8_t TxData[8]; // Data buffer for transmission
	CAN_TxHeaderTypeDef TxHeader; // Transmission header struct
	uint32_t mailbox = 0; // Mailbox index
	// Reset index if needed
	if (mainIndex >= NUM_MAIN_MESSAGES) { // Assume NUM_MAIN_MESSAGES is defined
		mainIndex = 0; // Reset to first message
	}
	// Prepare message based on index (example for sending status)
	TxHeader.StdId = TER_STATUS_FRAME_ID; // Example ID for status message
	TxHeader.DLC = TER_STATUS_LENGTH; // Length
	TxHeader.IDE = CAN_ID_STD; // Standard ID
	TxHeader.RTR = CAN_RTR_DATA; // Data frame
	ter_status_pack(TxData, &TeR.status, TxHeader.DLC); // Pack status data
	// Bare-metal send
	while ((mainCAN->TSR & CAN_TSR_TME0) == 0); // Wait for mailbox 0 empty
	mainCAN->sTxMailBox[0].TIR = (TxHeader.StdId << 21) | (TxHeader.IDE << 2) | (TxHeader.RTR << 1); // Set ID, IDE, RTR
	mainCAN->sTxMailBox[0].TDTR = TxHeader.DLC; // Set DLC
	mainCAN->sTxMailBox[0].TDLR = *(uint32_t*)TxData; // Low data bytes
	mainCAN->sTxMailBox[0].TDHR = *(uint32_t*)(TxData + 4); // High data bytes
	mainCAN->sTxMailBox[0].TIR |= CAN_TI0R_TXRQ; // Transmit request
	mainIndex++; // Increment index for next message
}

// Decode message function
void decodeMsg(CAN_TypeDef *hcan) {
  uint32_t id = hcan->sFIFOMailBox[0].RIR >> 21;  // Extract standard ID
  uint8_t dlc = hcan->sFIFOMailBox[0].RDTR & 0xF;  // Extract DLC
  uint32_t data_low = hcan->sFIFOMailBox[0].RDLR;  // Low data bytes
  uint32_t data_high = hcan->sFIFOMailBox[0].RDHR; // High data bytes
  uint8_t data[8] = {(data_low & 0xFF), ((data_low >> 8) & 0xFF), ((data_low >> 16) & 0xFF), ((data_low >> 24) & 0xFF),
                     (data_high & 0xFF), ((data_high >> 8) & 0xFF), ((data_high >> 16) & 0xFF), ((data_high >> 24) & 0xFF)};  // Pack data array
  logSCS(id);  // Log if SCS
  switch (id) {
	case TER_COMMAND_FRAME_ID: // Command system
		struct ter_command_t cmdMsg;  // Command message
		ter_command_init(&cmdMsg);    // Initialize to avoid uninitialized variables
		ter_command_unpack(&cmdMsg, data, dlc);  // Unpack data
		command(cmdMsg); // Call command interpretation (pass by copy)
		break;

		/* ---------------------------[TER]-------------------------- */

		// Message Decoding
	case TER_APPS_FRAME_ID:
		ter_apps_unpack(&TeR.apps, data, dlc);  // Unpack APPS message
		break;

	case TER_BPPS_FRAME_ID:
		ter_bpps_unpack(&TeR.bpps, data, dlc);  // Unpack BPPS message
		break;

	case TER_STEER_FRAME_ID:
		ter_steer_unpack(&TeR.steer, data, dlc);  // Unpack steer message
		break;

	case TER_FRONT_V_FRAME_ID:
		ter_front_v_unpack(&TeR.speed, data, dlc);  // Unpack front velocity message
		break;

	case TER_ANG_RATE_FRAME_ID:
		ter_ang_rate_unpack(&TeR.angRate, data, dlc);  // Unpack angular rate message
		break;

	case TER_LV_STATUS_FRAME_ID:
		ter_lv_status_unpack(&TeR.lvbms, data, dlc);  // Unpack LV status message
		break;

		/* ---------------------------[INVERTER]-------------------------- */

	case INVERTER_EMCU_STATE_2_RIGHT_FRAME_ID:
		inverter_emcu_state_2_right_unpack(&TeR.appStateRight, data,
				dlc);  // Unpack right inverter state 2
		break;

	case INVERTER_EMCU_STATE_2_LEFT_FRAME_ID:
		inverter_emcu_state_2_left_unpack(&TeR.appStateLeft, data, dlc);  // Unpack left inverter state 2
		break;

	case INVERTER_EMCU_STATE_3_RIGHT_FRAME_ID:
		inverter_emcu_state_3_right_unpack(&TeR.dqErpmRight, data, dlc);  // Unpack right state 3
		break;

	case INVERTER_EMCU_STATE_3_LEFT_FRAME_ID:
		inverter_emcu_state_3_left_unpack(&TeR.dqErpmLeft, data, dlc);  // Unpack left state 3
		break;

	case INVERTER_EMCU_STATE_4_RIGHT_FRAME_ID:
		inverter_emcu_state_4_right_unpack(&TeR.tempsRight, data, dlc);  // Unpack right temps
		break;

	case INVERTER_EMCU_STATE_4_LEFT_FRAME_ID:
		inverter_emcu_state_4_left_unpack(&TeR.tempsLeft, data, dlc);  // Unpack left temps
		break;


	case INVERTER_EMCU_STATE_7_LEFT_FRAME_ID:
		inverter_emcu_state_7_left_unpack(&TeR.demLeft, data, dlc);  // Unpack left state 7
		break;

	case INVERTER_EMCU_STATE_7_RIGHT_FRAME_ID:
		inverter_emcu_state_7_right_unpack(&TeR.demRight, data, dlc);  // Unpack right state 7
		break;

	case INVERTER_EMCU_STATE_9_LEFT_FRAME_ID:
		inverter_emcu_state_9_left_unpack(&TeR.trqEstLeft, data, dlc);  // Unpack left torque estimate
		break;

	case INVERTER_EMCU_STATE_9_RIGHT_FRAME_ID:
		inverter_emcu_state_9_right_unpack(&TeR.trqEstRight, data, dlc);  // Unpack right torque estimate
		break;

		/* ---------------------------[HVBMS]-------------------------- */

	case HVBMS_BMS_TX_STATE_3_FRAME_ID:
		hvbms_bms_tx_state_3_unpack(&TeR.BmsAppState, data, dlc);  // Unpack BMS app state
		break;
		/* ---------------------------[Default]-------------------------- */

	default:
		return;  // Unknown ID, return
		break;

	}
  hcan->RF0R |= CAN_RF0R_RFOM0;  // Release FIFO
}